// document provides examples demonstrating syntax of language
// comments are only about syntax and not about purpose of code (e.g. explaining the algorithm)


// bubblesort algorithm for control flow syntax

// import the std.span module
import std.range;
import std.typing;


// "bubblesort" = name of function
// "()" parameter list
// "template" generic parameter type
// "span" variable name
bubblesort(constant span : std::Range)
{
    // "success_count" = variable name
    // " : <type> " = variable DATA type
    // "{}" = initialization braces
    success_count : std::return_type(span.size) {};

    // for loops 3 segments
    // initialization, condition, iteration
    for (iterator {span.begin()}; success_count + 1 != span.size(); iterator++)
    {
        success_count = 0;

        for (sub_iterator {span.begin()}; sub_iterator != span.end(); sub_iterator++)
        {
            // '&' = variable type, data type is automatic
            value : & {*iterator};
            next_value : & {*(iterator + 1)};

            // standard c-style if statement
            if (iterator != next_value)
            {
                // type is omitted so compiler has to generate it
                temporary {value};
                value = next_value;
                next_value = temporary;
            }
            else
            {
                // call increment operator on "success_count"
                success_count++;
            }
        }
    }
}


// max parenthese depth algorithm for modular programming

import std.algorithm;
import std.string;
import std.regex;

// note very slow algorithm due to too redundant iterations (just for demonstration)
maximum_parenthese_depth(constant string : std::StringView) -> Size
{
    // c-style return statement
    return 
        std::max(
            std::partial_sum(
                std::scan(
                        std::scan(
                            memory_cast<SignedByte[]>(
                                std::filter(string, std::regex::expression {"()"})
                            ),
                            cast<SignedByte>('('),
                            1
                        ),
                    memory_cast<SignedByte>(')'),
                    -1
                )
            )
        )
};